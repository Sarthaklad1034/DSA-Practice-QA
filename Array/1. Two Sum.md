
<div align="center">

# 1. Two Sum

</div>

---

## üìù Problem Statement

Given an array of integers `nums` and an integer `target`, return **indices of the two numbers such that they add up to target**.

You may assume that each input would have **exactly one solution**, and you may not use the same element twice.

You can return the answer in any order.

---

## üîç Examples

| Example | Input | Output | Explanation |
|--------|-------|--------|-------------|
| 1 | `nums = [2,7,11,15]`, target = 9 | `[0,1]` | 2 + 7 = 9 |
| 2 | `nums = [3,2,4]`, target = 6 | `[1,2]` | 2 + 4 = 6 |
| 3 | `nums = [3,3]`, target = 6 | `[0,1]` | 3 + 3 = 6 |

---

## ‚öôÔ∏è Constraints

- 2 <= nums.length <= 10‚Å¥  
- -10‚Åπ <= nums[i] <= 10‚Åπ  
- -10‚Åπ <= target <= 10‚Åπ  
- **Only one valid answer exists.**

---

## üõ†Ô∏è Solution Approaches

### ‚úÖ Approach 1: Brute Force (Java)

For every pair of elements, check if they sum up to the target.

```java
class Solution { 
    public int[] twoSum(int[] nums, int target) {
        for ( int i = 0; i < nums.length; i++ ) {
            for ( int j = i + 1; j < nums.length; j++ ) {
                if ( nums[i] + nums[j] == target ) {
                    int a[] = {i, j};
                    return a;
                }
            }
        }
        return null;
    }
}
```

**Time Complexity:** `O(n^2)`  
**Space Complexity:** `O(1)`

---

### üöÄ Approach 2: HashMap Optimization (Java)

Use a HashMap to store complement values for faster lookup.

```java
import java.util.HashMap;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (map.containsKey(complement)) {
                return new int[] { map.get(complement), i };
            }
            map.put(nums[i], i);
        }
        return null;
    }
}
```

**Time Complexity:** `O(n)`  
**Space Complexity:** `O(n)`

---

### üêç Approach 3: Python Brute Force

```python
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        for i in range(len(nums)):
            for j in range(i + 1, len(nums)):
                if nums[i] + nums[j] == target:
                    return [i, j]
        return None
```

**Time Complexity:** `O(n^2)`  
**Space Complexity:** `O(1)`

---

## üèÜ Comparison of Approaches

| Approach                | Language | Time Complexity | Space Complexity | Pros                   | Cons                    |
|------------------------|----------|------------------|-------------------|------------------------|-------------------------|
| Brute Force            | Java     | O(n^2)           | O(1)              | Simple to implement    | Inefficient for large n |
| HashMap Optimization   | Java     | O(n)             | O(n)              | Efficient              | Extra space needed      |
| Brute Force            | Python   | O(n^2)           | O(1)              | Simple syntax          | Slower for large inputs |

---

## üß™ Test Cases

```java
System.out.println(Arrays.toString(new Solution().twoSum(new int[]{2,7,11,15}, 9))); // [0,1]
System.out.println(Arrays.toString(new Solution().twoSum(new int[]{3,2,4}, 6)));     // [1,2]
System.out.println(Arrays.toString(new Solution().twoSum(new int[]{3,3}, 6)));       // [0,1]
```

```python
print(Solution().twoSum([2,7,11,15], 9))  # [0,1]
print(Solution().twoSum([3,2,4], 6))      # [1,2]
print(Solution().twoSum([3,3], 6))        # [0,1]
```

---

<div align="center">

üí° *Hashing* ‚Ä¢ *Brute Force* ‚Ä¢ *Array Traversal*

</div>
